using H.Services.Logger;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace H.Extensions.Encryption.String;

/// <summary>
/// DES用于加密内容较多的敏感信息
/// </summary>
public static class DESExtension
{
    //默认密钥向量 
    private static byte[] Keys = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF };
    /// <summary> 
    /// DES加密字符串 
    /// </summary> 
    /// <param name="value">待加密的字符串</param> 
    /// <param name="encryptKey">加密密钥,要求为8位</param> 
    /// <returns>加密成功返回加密后的字符串，失败返回源串</returns> 
    public static string EncryptDES(this string value, string encryptKey = "12345678")
    {
        try
        {
            byte[] rgbKey = Encoding.UTF8.GetBytes(encryptKey.Substring(0, 8));
            byte[] rgbIV = Keys;
            byte[] inputByteArray = Encoding.UTF8.GetBytes(value);
            var dCSP = DES.Create();
            MemoryStream mStream = new MemoryStream();
            CryptoStream cStream = new CryptoStream(mStream, dCSP.CreateEncryptor(rgbKey, rgbIV), CryptoStreamMode.Write);
            cStream.Write(inputByteArray, 0, inputByteArray.Length);
            cStream.FlushFinalBlock();
            return Convert.ToBase64String(mStream.ToArray());
        }
        catch (Exception ex)
        {
            IocLog.Instance?.Error(ex);
            return value;
        }

    }

    /// <summary> 
    /// DES解密字符串 
    /// </summary> 
    /// <param name="value">待解密的字符串</param> 
    /// <param name="decryptKey">解密密钥,要求为8位,和加密密钥相同</param> 
    /// <returns>解密成功返回解密后的字符串，失败返源串</returns> 
    public static string DecryptDES(this string value, string decryptKey = "12345678")
    {
        try
        {
            byte[] rgbKey = Encoding.UTF8.GetBytes(decryptKey);
            byte[] rgbIV = Keys;
            byte[] inputByteArray = Convert.FromBase64String(value);
            var DCSP = DES.Create();
            MemoryStream mStream = new MemoryStream();
            CryptoStream cStream = new CryptoStream(mStream, DCSP.CreateDecryptor(rgbKey, rgbIV), CryptoStreamMode.Write);
            cStream.Write(inputByteArray, 0, inputByteArray.Length);
            cStream.FlushFinalBlock();
            return Encoding.UTF8.GetString(mStream.ToArray());
        }
        catch (Exception ex)
        {
            IocLog.Instance?.Error(ex);
            return value;
        }

    }

}
